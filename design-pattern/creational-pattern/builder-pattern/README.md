# 最佳实践
在使用建造者模式的时候考虑一下模板方法模式，别孤立地思考一个模式，僵化地套用一个模式会让你受害无穷！
# 简介
建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。
# 定义
Separate the construction of a complex object from its representation so that the same
construction process can create different representations.（将一个复杂对象的构建与它的表示分
离， 使得同样的构建过程可以创建不同的表示。）<br>
在建造者模式中， 有如下4个角色：<br>
● Product产品类<br>
通常是实现了模板方法模式，也就是有模板方法和基本方法。
● Builder抽象建造者<br>
规范产品的组建，一般是由子类实现。<br>
● ConcreteBuilder具体建造者<br>
实现抽象类定义的所有方法，并且返回一个组建好的对象。
● Director导演类<br>
负责安排已有模块的顺序，然后告诉Builder开始建造。<br>
# 意图
将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。
# 主要解决
主要解决在软件系统中，有时候面临着"一个复杂对象"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。
# 何时使用
一些基本部件不会变，而其组合经常变化的时候。
# 如何解决
将变与不变分离开。
# 关键代码
建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。
# 应用实例：
1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的"套餐"。<br>
2、JAVA 中的 StringBuilder。<br>
# 优点：
1、封装性。使用建造者模式可以使客户端不必知道产品内部组成的细节。<br>
2、建造者独立，易扩展。<br>
3、便于控制细节风险。<br>
# 缺点：
1、产品必须有共同点，范围有限制。<br>
2、如内部变化复杂，会有很多的建造类。<br>
# 使用场景：
1、相同的方法，不同的执行顺序，产生不同的事件结果时，可以采用建造者模式。<br>
2、多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时，则可以使用该模式。<br>
3、产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，这个时候使用建造者模式非常合适。<br>
4、在对象创建过程中会使用到系统中的一些其他对象，这些对象在产品对象的创建过程中不易得到时，也可以采用建造者模式封装该对象的创建过程。该种场景只能是一个补偿方法，因为一个对象不容易获得，而在设计阶段竟然没有发觉，而要通过创建者模式柔化创建过程，本身已经违反设计的最初目标。<br>
# 注意事项
与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。<br>
# 实现
我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。
我们将创建一个表示食物条目（比如汉堡和冷饮）的 Item 接口和实现 Item 接口的实体类，以及一个表示食物包装的 Packing 接口和实现 Packing 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。
然后我们创建一个 Meal 类，带有 Item 的 ArrayList 和一个通过结合 Item 来创建不同类型的 Meal 对象的 MealBuilder。BuilderPatternDemo，我们的演示类使用 MealBuilder 来创建一个 Meal。<br>
![uml](uml_diagram.jpeg "uml")
